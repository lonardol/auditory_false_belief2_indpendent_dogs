---
title: "Auditory_FB_dogs_power_analysis"
author: "Christoph VÃ¶lter, Lucrezia Lonardo"
date: "2024-07-25"
output: html_document
---
## Load libraries and workspace
```{r}
rm(list=ls())
library(tidyverse)
library(cowplot)
library(gghalves)
library(ggthemes)
library(lme4)
# Loading required package: Matrix
library(kyotil) # we want to store info about convergence issues

#load("power_sim_Auditory_FB2.RData") 
```

Notes: between subject design, prediction: cooperative dogs follow suggestion more often in FB than TB. Independent dogs other way around.
## Generate data, informed by the values in Lonardo et al. (2025)

```{r}
set.seed(1)
n.subject <- seq(from=312, to=540, by=12)# number subjects (from 104 to 180 per condition). 
n.per.subject <- 1 # observations per subject
n.per.condition <- 1 # observations per subject and condition
subj.id <- as.factor(paste("subj", 1:n.subject, sep = "."))
age.range=c(10:168) 
breed = c("akita_inu","andalusian_hound","appenzell_cattle_dog",               "australian_cattle_dog", "australian_shepherd","austrian_pinscher",                 
"basenji","beagle","belgian_shepherd","bernese_mountain_dog", "bobtail",                 "bohemian_shepherd_dog","border_collie","bouvier_des_flandres", "brittany_spaniel","bullmastiff","canarian_warrenhound","cocker_spaniel",
"collie","dalmatian","danish_swedish_farmdog","dutch_shepherd","english_springer_spaniel", "entlebucher_mountain_dog","flat_coated_retriever","french_water_dog",       "german_longhaired_pointer","german_pinscher","german_shepherd","german_short_haired_pointer","german_spitz", "german_wirehaired_pointer","golden_retriever","great_swiss_mountain_dog","greyhound","hovawart","hungarian_shorthaired_pointer","icelandic_sheepdog",
"irish_setter","italian_spinone","kleiner_muensterlaender","labrador_retriever",          
"miniature_american_shepherd","miniature_pinscher","mudi", "nova_scotia_duck_tolling_retriever","picardy_spaniel","portuguese_water_dog", "romagna_water_dog","rottweiler","samoyed","schnauzer","shetland_sheepdog",           "siberian_husky","silken_windsprite","spanish_water_dog","weimaraner",                "welsh_corgi","whippet","white_swiss_shepherd", #until here breeds in Lonardo et al. (2025), below I added some hypothetical terrier breeds
"jack_russel_terrier", "parson_russel_terrier", "border_terrier", "west_highland_white_terrier", "yorkshire_terrier", "fox_terrier", "scottish_terrier", "skye_terrier")
 # c("fci1","fci3","fci2","fci5","fci6","fci7", "fci8", "fci10") #includes both cooperative and independent breed groups that were included in Lonardo et al. (2021)

fb.per<-.50
tb.per<-.39 
knctr.per<-.38

indep.per=0.4
coop.per=0.5

start.data <- data.frame(subj.id)

xdata=data.frame(expand.grid(condition=c("false_belief", "true_belief", "knowledge_sound_control"), sex=c("F", "M"), baited.fst=c("blue", "grey"), breed_type=c("cooperative", "independent")))
m.mat=model.matrix(object=~condition*breed_type+sex+baited.fst, data=xdata)

start.data<-cbind(start.data, xdata) #useful for creating counterbalancing

table(start.data$condition, start.data$sex)
table(start.data$baited.fst, start.data$sex)
table(start.data$condition, start.data$baited.fst)
table(start.data$condition, start.data$breed_type)
```
## Checks
```{r}
# does each subject have only one condition and sex?
xx <- table(start.data$subj.id, start.data$condition)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$subj.id, start.data$sex)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$subj.id, start.data$breed_type)
range(apply(X = xx > 0, MARGIN = 1, sum))
```

```{r}
# random effects for breed

#LL: Std. Error of condition (fixed effect) was estimated to be  0.443 in Lonardo et al. (2021)
#Variance and st. dev of condition within breed (random effect) estimated 0
# of Intercept within breed (re) var = 0.1371   sd = 0.3703 

# educated guess of what the random effect could be
# (based on the qlogis of the reference level performance)
#r.effects <- c(abs(qlogis(fb.per)))  = 0
r.effects <- 0.001

# random slope for condition and sex within breed
r.slope.condition <- -0.45  #abs(qlogis(fb.per))-abs(qlogis(tb.per))
# r.slope.sex <- 0.4 
# r.slope.baited.fst <- 0.4
# r.slope.age <- 0.4

```




## Simulation

```{r eval=FALSE, include=FALSE}
#LL:reset to higher number
n.simus <- 100

all.res.all.samples <- data.frame()

# define control structure to make convergence more likely:
contr <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000), nAGQ=FALSE)

for (j in 1:length(n.subject)) {

  # create object to store the simulation parameters and results:

  all.res <- data.frame(expand.grid(
   # n.subject=n.subject, 
    r.effect = r.effects,
    n.per.subject = n.per.subject, 
    r.slope.condition = r.slope.condition,
    fb.per = fb.per,
    tb.per = tb.per,
    knctr.per =knctr.per,
   # r.slope.sex = r.slope.sex,
   # r.slope.baited.fst = r.slope.baited.fst, 
   # r.slope.age = r.slope.age,
    simu = 1:n.simus
  ))
  all.res$n.subject<-n.subject[j]
  all.res$icpt <- NA
  all.res$conditiontb <- NA
  all.res$conditionknctr <- NA
  all.res$condition:breed_type<- NA
  all.res$sexM <- NA
  all.res$baited.fstgrey <- NA
  all.res$breed_typeindependent <- NA
  all.res$z.age <- NA
  all.res$re.sd <- NA
  # all.res$lrt.p.con.know <- NA
  # all.res$lrt.p.con.knctr <- NA
  all.res$lrt.p.con<- NA
  #all.res$lrt.p.z.age <- NA
  #all.res$lrt.p.sex <- NA
  #all.res$lrt.p.baited.fst <- NA
  all.res$warns.full <- NA
  all.res$warns.null <- NA
  #all.res$full.null.p <- NA

  
  all.ests <- matrix(NA, nrow = n.simus, ncol = 1)
  colnames(all.ests) <- c("lrt.p.con")

# create data frame with design:
start.data <- data.frame(subj.id = as.factor(paste("subj", str_pad(1:n.subject[j], 2, pad = "0"), sep = "."))) 
xdata=data.frame(expand.grid(condition=c("false_belief", "true_belief", "knowledge_sound_control"), sex=c("F", "M"), baited.fst=c("blue", "grey"), breed_type=c("cooperative", "independent")))
start.data<-cbind(start.data, xdata)
  # add age and breed (if they should be generated in each loop)
  age <- sample(x = age.range, size = length(unique(start.data$subj.id)), replace = T)
  start.data$age <- as.numeric(age[as.numeric(start.data$subj.id)])
  start.data$z.age <- as.vector(scale(as.numeric(start.data$age))) 
  start.data$breed <- as.factor(sample(x = breed, size = length(unique(start.data$subj.id)), replace = T))
                              
                              
  # dummy code factors
start.data$condition <- as.factor(start.data$condition)
start.data$condition.dummy1 <- as.numeric(start.data$condition == levels(start.data$condition)[2])
start.data$condition.dummy2 <- as.numeric(start.data$condition == levels(start.data$condition)[3])
#start.data$sex.dummy1 <- as.numeric(start.data$sex)
#start.data$baited.fst.dummy1 <-as.numeric(start.data$baited.fst)

  # center condition for random slopes:
start.data$condition.dummy1.c <- start.data$condition.dummy1 - mean(start.data$condition.dummy1)
start.data$condition.dummy2.c <- start.data$condition.dummy2 - mean(start.data$condition.dummy2)
  # center sex for random slopes:
  # start.data$sex.dummy1.c <- start.data$sex.dummy1 - mean(start.data$sex.dummy1)
  # center first baited box for random slopes:
  # start.data$baited.fst.dummy1.c <- start.data$baited.fst.dummy1 - mean(start.data$baited.fst.dummy1)
  

xdata <- start.data

# run simulation
for (i in 1:nrow(all.res)) {
  set.seed(i) # allows to later replicate individual simulations

  #sample age
  xdata$age <- as.numeric(age[as.numeric(xdata$subj.id)])
  xdata$z.age <- as.vector(scale(as.numeric(xdata$age))) 
  #sample breed
  xdata$breed <- as.factor(sample(x = breed, size = length(unique(xdata$subj.id)), replace = T))

  m.mat <- model.matrix(object = ~ condition*breed_type+sex+baited.fst+z.age, data = xdata) # create model martix 

  
  coefs <- c(
      "(Intercept)" = log(all.res[i, "fb.per"] / (1 - all.res[i, "fb.per"])),
      "conditiontrue_belief" = log(all.res[i, "tb.per"] / (1 - all.res[i, "tb.per"] )) - log(all.res[i, "fb.per"] / (1 - all.res[i, "fb.per"])),
      "conditionknowledge_sound_control" = log(all.res[i, "knctr.per"] / (1 - all.res[i, "knctr.per"] )) - log(all.res[i, "fb.per"] / (1 - all.res[i, "fb.per"])),
      "breed_typeindependent"= log(all.res[i, "indep.per"] / (1 - all.res[i, "indep.per"] )) - log(all.res[i, "coop.per"] / (1 - all.res[i, "coop.per"])),
      "condition:breed_type" = log(all.res[i, "tb.per"] / (1 - all.res[i, "tb.per"] )) - log(all.res[i, "fb.per"] / (1 - all.res[i, "fb.per"])) - log(all.res[i, "indep.per"] / (1 - all.res[i, "indep.per"] )) - log(all.res[i, "coop.per"] / (1 - all.res[i, "coop.per"])),
      "sexM" = 0,
      "baited.fstgrey" = 0,
      "z.age" = -0.49 #based on model estimate in Lonardo et al. (2021) Table S5
    )

  LP <- m.mat[, names(coefs)] %*% coefs # LP wrt fixed effects
  
  # add random effect to linear predictor:
      LP <- LP + rnorm(n = n.subject[j], sd = all.res[i, "r.effect"])[as.numeric(xdata$breed)] +
       # rnorm(n = n.subject[j], sd = all.res[i, "r.slope.age"])[as.numeric(xdata$breed)] * xdata$z.age +
        rnorm(n = n.subject[j], sd = all.res[i, "r.slope.condition"])[as.numeric(xdata$breed)] * xdata$condition.dummy1.c  +
        rnorm(n = n.subject[j], sd = all.res[i, "r.slope.condition"])[as.numeric(xdata$breed)] * xdata$condition.dummy2.c 
       # rnorm(n = n.subject[j], sd = all.res[i, "r.slope.baited.fst"])[as.numeric(xdata$breed)] * xdata$baited.fst.dummy1.c +
       # rnorm(n = n.subject[j], sd = all.res[i, "r.slope.sex"])[as.numeric(xdata$breed)] * xdata$sex.dummy1.c 
          

  # generate response:
xdata$choice <- rbinom(n = nrow(xdata), size = 1, prob = exp(LP) / (1 + exp(LP)))

  # fit full model:
  full <- keepWarnings(glmer(choice ~ condition*breed_type + sex + baited.fst + z.age +
       (1 + condition.dummy1.c + condition.dummy2.c | breed), 
			 family=binomial, data=xdata, control=contr
    ))
  
  
  
  #LL: with the first full model I tried to fit I got this error: number of observations (=120) < number of random effects (=216) for term (1 + sex.dummy1.c + condition.dummy1.c + condition.dummy2.c + baited.fst.dummy1.c + z.age | breed); the random-effects parameters are probably unidentifiable
  #So I removed the random slope of baited.fst, but got a similar error, 
  #so I also removed the r.s. of age, but got again a similar error, 
  #so I removed also the r.s. of sex
  
  
  
   # fit null model: (to get a test of condition as a whole)                                  
   null <- keepWarnings(glmer(choice ~ sex+baited.fst+z.age +
       (1 | breed), 
 			 family=binomial, data=xdata, control=contr
   ))
   
  #calculate average performance
   xdata_agg<- xdata %>%
  group_by(condition, breed_type)%>%
  summarise(mean_choice = mean(choice))
   
  # store results:
  all.res[i, c("icpt", "condition:breed_type","sexM", "baited.fstgrey", "z.age")] <- fixef (full$value)
  all.res[i, "warns.full"] <- nchar(paste(full$warnings, collapse = ""))
  all.res[i, "warns.null"] <- nchar(paste(null$warnings, collapse = ""))
  all.res[i, "re.sd"] <- as.data.frame(summary(full$value)$varcor)[1, "sdcor"]
  # all.res[i, "lrt.p.con.know"] <- as.data.frame(drop1(full$value, test = "Chisq"))["conditionknowledge", "Pr(>Chisq)"]   #LL: drop1 does not seem to yield p values 
  # all.res[i, "lrt.p.con.knctr"] <- as.data.frame(drop1(full$value, test = "Chisq"))["conditionknowledge_sound_control", "Pr(>Chisq)"]
  # all.res[i, "lrt.p.con"] <- as.data.frame(drop1(full$value, test = "Chisq"))["condition", "Pr(Chisq)"]
  #all.res[i, "lrt.p.age"] <- as.data.frame(drop1(full$value, test = "Chisq"))["z.age", "Pr(>Chisq)"]
 # all.res[i, "lrt.p.sex"] <- as.data.frame(drop1(full$value, test = "Chisq"))["sexM", "Pr(>Chisq)"]
 # all.res[i, "lrt.p.baited.fst"] <- as.data.frame(drop1(full$value, test = "Chisq"))["baited.fstgrey", "Pr(>Chisq)"]
 # all.res[i, "full.null.p"] <- as.data.frame(anova(null$value, full$value, test = "Chisq"))[2, "Pr(>Chisq)"]
 all.res[i, "lrt.p.con"] <- as.data.frame(anova(null$value, full$value, test = "Chisq"))[2, "Pr(>Chisq)"]
 all.res[i, c("mean_choice_fb_indpendent","mean_choice_fb_cooperative","mean_choice_tb_independent","mean_choice_tb_cooperative","mean_choice_knctr_independent", "mean_choice_knctr_cooperative"  )]<-xdata_agg$mean_choice

                             
   print(c("sim # =",i, " sample size =" , n.subject[j]))
  }
 
all.res.all.samples <- rbind(all.res.all.samples, all.res)

}

save.image("power_sim_Auditory_FB2.RData")
```
## Evaluation of results 

* number of warning per combinations of random effects (out of 1000 models per cell)  
Full model:  
```{r echo=FALSE}
#full model
tapply(X=all.res.all.samples[, "warns.full"]>0, INDEX=all.res.all.samples[, c("n.subject", "fb.per", "tb.per", "knctr.per", "indep.per", "coop.per", "r.effect")],
FUN=sum)
#warning codes: 

```


## Only models that converged are evaluated from here on:  

```{r include=FALSE}
all.res2=subset(all.res.all.samples, warns.full==0)
```


### How many models converged, have a significant full-null model comparison, and a significant LRT of condition?  
```{r echo=FALSE}
n.converged<- all.res2%>%
    group_by(n.subject, fb.per, tb.per, knctr.per, indep.per, coop.per, r.effect ) %>% 
  summarise(n.converged=length(lrt.p.con))
n.converged #

lrt.data2 <- all.res2 %>%
  #filter(full.null.p<0.025)%>%
  group_by(n.subject,fb.per, tb.per, coop.per, indep.per, knctr.per, r.effect) %>% 
  summarise(lrt.p.con.median = median(lrt.p.con), 
           # lrt.p.trial.median = median(lrt.p.trial),
          #  lrt.p.age.median = median(lrt.p.age),
            n.sign.lrt.con = length(lrt.p.con[lrt.p.con < 0.025]),
           # n.sign.lrt.trial = length(lrt.p.trial[lrt.p.trial < 0.05]),
           # n.sign.lrt.age = length(lrt.p.order[lrt.p.age < 0.05]),
            n.lrt = n.simus,
            proportion.sign.lrt.con = length(lrt.p.con[lrt.p.con < 0.025]) / n.simus,
            mean_choice_fb=mean(mean_choice_fb),
            mean_choice_know_=mean(mean_choice_tb),
            mean_choice_knctr=mean(mean_choice_knctr)) %>%
           # proportion.sign.lrt.trial = length(lrt.p.trial[lrt.p.trial < 0.05]) / n.simus,
            #proportion.sign.lrt.age = length(lrt.p.age[lrt.p.age < 0.05]) / n.simus)%>%
  full_join(n.converged)

lrt.data2
save.image("power_sim_Auditory_FB2.RData")
```

###Plotting 

```{r}
plot.sample.sizes.power.auditory_FB<-ggplot(lrt.data2, aes(x=n.subject, y=proportion.sign.lrt.con*100)) +
  geom_bar(stat="identity") +
  ylab("Power (% significant LRT)") + 
  xlab("Total sample size") +
  xlim(x=c(120,250)) +
  scale_x_continuous(breaks = lrt.data2$n.subject) +
  geom_hline(yintercept=80, col="blue", lty=2, lwd=.9) +
  theme_classic()
ggsave(plot.sample.sizes.power.auditory_FB, filename = "./plot/sample_sizes_power_analysis_auditory_FB.png", scale = 0.55, height = 6, width = 10)
```

```{r}
xdata_agg<- xdata %>%
  group_by(condition)%>%
  summarise(mean_choice = mean(choice))
 
ggplot(xdata_agg, aes(x = condition, y = mean_choice)) +
  geom_bar(stat="identity")
```


#### Plotting the proportion of significant LRTs for the predictor variable condition ONLY based on models that converged and with a significant full-null model comparison
```{r echo=FALSE}

# New facet label names for knctr.per variable
knctr.per.labs <- c("LL: 0.4", "LL: 0.5")
names(knctr.per.labs) <- c("0.4", "0.5")

# New facet label names for n.subject variable
n.subject.labs <- c( "N = 48", "N = 60", "N = 72")
names(n.subject.labs) <- c("48", "60", "72")

p.con.power <- ggplot(data = lrt.data2, aes(x=as.factor(fb.per) ,y = proportion.sign.lrt.con, fill=as.factor(tb.per))) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  scale_y_continuous(breaks=seq(0,1,0.2), limits=c(0, 1))+
  geom_hline(yintercept = 0.8, colour = "black", lwd = 1, lty = 2) +
   # geom_hline(yintercept = 0.05, colour = "darkgrey", lwd = 1.1, lty = 4) +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))+
  labs(fill = "HL condition", y="Power", x= "HH condition") +
  theme_bw()+
  ggtitle("Different sample sizes (48 - 72), Absent entities")+
  geom_text(aes(label=round(proportion.sign.lrt.con,2)), position=position_dodge(width=0.9), vjust=-0.25)+
  facet_grid(knctr.per~n.subject, labeller = labeller(knctr.per = knctr.per.labs, n.subject = n.subject.labs))
  #theme(legend.position="none")
p.con.power
```


```{r echo=FALSE}
ggsave(p.con.power, filename = "absent_entities_power_differentNs_power3.png", scale = 0.55, height = 12, width = 16)
```




